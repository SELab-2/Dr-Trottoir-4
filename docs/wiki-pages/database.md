For this project we have chosen [PostgreSQL](https://www.postgresql.org/) as our database of choice. In combination with
Django ORM, it allows for faster development because the ORM eliminates the need for us to write any SQL code and also gives 
advantages such as protection against SQL injection out of the box without needing any extra setup or work. The database
also becomes easier to modify when needed.

## Overall structure
For the overall structure of our database, more specifically our EER diagram and logical design, please click [here]().

## Models
Django ORM works with models specified in [models.py](https://github.com/SELab-2/Dr-Trottoir-4/blob/develop/backend/base/models.py)
to generate our database. Every model corresponds to a table in our database, giving us an easy and fast way to add, edit
and remove tables where necessary. For more detailed information about how you can make these models, click [here](https://docs.djangoproject.com/en/4.1/topics/db/models/)

## Migrations
Django migrations are used to propagate changes made in our models ([models.py](https://github.com/SELab-2/Dr-Trottoir-4/blob/develop/backend/base/models.py)) to our database schema.
Below we will give a general overview of how they work, but a more detailed guide can be found [here](https://docs.djangoproject.com/en/4.1/topics/migrations/).

### Model migrations

To create a new migration based on the changes you have made to the model in [models.py](https://github.com/SELab-2/Dr-Trottoir-4/blob/develop/backend/base/models.py), use the command:
```python manage.py makemigrations```

but in our case we need to execute this in our docker container (in the project directory), so we use instead:

```
docker-compose exec backend python manage.py makemigrations
```

Make sure that your docker container is running with `docker-compose up`.

New migrations that are created have a unique identifier, this identifier is just an autoincremented id. 

There are already some migration files in our project, these can be found in the [migrations](https://github.com/SELab-2/Dr-Trottoir-4/tree/develop/backend/base/migrations) folder. 

**Warning**:
**The filenames and content of these files can never be changed, as this will cause problems for those who already executed these migrations!**
> This is because django keeps track of a migration history inside the database, in this table the filename is tracked.

**Instead just create a new migrations on top of the already executed migrations.**

The migrations that are created with the commands above, need to be migrated to the database. This is where this command comes in: ```
python manage.py migrate```

Or in our case again inside a docker container:

```
docker-compose exec backend python manage.py migrate
```

In order to simplify this process a bit, we have provided a script that makes the migrations and migrates them at the same time.
Just use 
```bash
$ ./migrations.sh
```
in the root of the project directory.

### Data migrations
We can also use migrations to insert (or remove) data in our database. These are called data migrations, more info can be found [here](https://docs.djangoproject.com/en/4.1/topics/migrations/#data-migrations).

To create a new autogenerated data migration we can use the command:
```python manage.py makemigrations --empty yourappname```

but because we use docker and our app is called *drtrottoir*, we use the command:
```
docker-compose exec backend python manage.py makemigrations --empty drtrottoir
```

In this migration we can then define a function that inserts/removes data. 
This needs to be added to the operations list inside the migration class and then the migration can be executed by using the same command as with model migrations:
```
docker-compose exec backend python manage.py migrate
```

## Fixtures
**Fixtures** in django are another useful way to dump data and add the data to our database, and they are our preferred
method. An example of a fixtures file is [datadump.json](https://github.com/SELab-2/Dr-Trottoir-4/blob/develop/backend/datadump.json).

In order to create a data dump of our database file using docker, we can use the command:
```bash
docker-compose exec backend python manage.py dumpdata --natural-foreign --natural-primary -e contenttypes -e auth.Permission --indent 4 -o <output_name>.json
```
There are other file extension possible but this will do for our test data.

### Clean up

Before loading the data in the database, we want to make sure it's empty to avoid any conflicts. Follow the steps below
to achieve this.

#### Step 1: Get postgres container ID

Execute the following command:

```bash
docker ps
```

This will give you the `CONTAINER_ID` for the `postgres:15-alpine` image.

#### Step 2: Drop / Create the database

Execute following commands:

```
docker exec -it <CONTAINER_ID> psql -U django -d postgres -c "DROP DATABASE drtrottoir WITH(FORCE);"   
```

and

```
docker exec -it <CONTAINER_ID> psql -U django -d postgres -c "CREATE DATABASE drtrottoir;"   
```

#### Step 3: Migrate database

```bash
../migrations.sh
```

### Loading the fixture
To load the data in the database, use the command:

```bash
docker-compose exec backend python manage.py loaddata <fixturename>
```

This means that if you want to load our example fixture, you have to run:
```bash
docker-compose exec backend python manage.py loaddata datadump.json
```

### Our example fixture
The example fixture we have provided will serve as a good initial batch of data for testing purposes. 
Please note that not all tables have been filled; below is a list of those that have been filled:
<ul>
    <li>Building on tours</li>
    <li>Buildings</li>
    <li>Garbage Collections</li>
    <li>Regions</li>
    <li>Student at buildings on tours</li>
    <li>Tours</li>
    <li>Users</li>
    <li>Manual</li>
    <li>Email templates</li>
</ul>

There are currently 22 users, all of whom share the same password `drtrottoir123`.
The names of these users have been chosen to make it easier to recognize what role they have:
<ul>
    <li>Users whose name start with <code>Ad</code> are admins </li>
    <li>Users whose name start with <code>St</code> are students </li>
    <li>Users whose name start with <code>Su</code> are superstudents </li>
    <li>Users whose name start with <code>Sy</code> are syndics </li>
</ul>

Additionally, male names indicate that the user's region is set to `Gent`, whereas female names indicate that a user's
region is set to `Antwerpen`.

To make logging into the [admin](http://localhost/api/adminn) page easier with these users, there is also an admin/superuser whose email address is set
to `admin@test.com`.


More information about fixtures can be found [here](https://docs.djangoproject.com/en/4.1/howto/initial-data/).

## Viewing the data

### Viewing the data in postgres
This option is mainly meant for whenever you really want to be able to execute SQL and as such, you will probably not need
it much if at all. We'll still cover it however just in case.

To check whether the data has been correctly inserted into the database, we can log onto the postgres docker container:
We can do this by first checking our running containers, using the command:
```
$ docker ps
CONTAINER ID   IMAGE                COMMAND                  CREATED              STATUS              PORTS                                                              NAMES
7742c9f9dfcb   project-frontend     "docker-entrypoint.s…"   About a minute ago   Up About a minute                                                                      project-frontend-1
075ff1639b24   project-backend      "python manage.py ru…"   About a minute ago   Up About a minute                                                                      project-backend-1
32771801b817   reverseproxy         "/docker-entrypoint.…"   About a minute ago   Up About a minute   0.0.0.0:80->80/tcp, 0.0.0.0:443->443/tcp, 0.0.0.0:2002->2002/tcp   project-reverseproxy-1
68e6b6e00ab1   postgres:15-alpine   "docker-entrypoint.s…"   26 hours ago         Up About a minute   0.0.0.0:5432->5432/tcp
```
In the output we can view the `CONTAINER ID` the postgres container has, in this case it is `68e6b6e00ab1`.

Finally, we can log onto the container with the command:
```
$ docker exec -it <container_id> psql -U django drtrottoir
```
here you replace `<container_id>` with the corresponding container id.

Now if we want to do any operation in SQL, we can do so. The tables that are created in the database get named by django. Django names the tables like `appname_modelname`.

For example if we want the rows of our users, we can type:

```
drtrottoir=# SELECT * from drtrottoir_user;
```

To get a list of all tables created by django, you can use the command:
```
drtrottoir=# \dt
```

### Viewing the data on the admin page
Alternatively, you can head over to the [admin page](http://localhost/api/admin) to get a GUI to view the contents of the
database. You can also easily add, remove and edit entries on the admin page without having to write any SQL code.